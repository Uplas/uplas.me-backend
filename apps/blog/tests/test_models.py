from django.test import TestCase
from django.contrib.auth import get_user_model
from django.utils import timezone
from django.db import IntegrityError
from django.utils.text import slugify
from django.contrib.contenttypes.models import ContentType # For GenericRelation tests

from apps.blog.models import (
    BlogCategory, BlogPostTag, BlogPost, BlogComment,
    BLOG_POST_STATUS_CHOICES
)
# Assuming a Like model exists, e.g., in community, for GenericRelation testing
# from apps.community.models import Like # Example if using community's Like model

User = get_user_model()

class BlogModelTestDataMixin:
    """
    Mixin to provide common setup data for blog-related model tests.
    """
    @classmethod
    def setUpTestData(cls):
        # Create users
        cls.author_user = User.objects.create_user(
            username='blog_author1',
            email='blogauthor1@example.com',
            password='password123',
            full_name='Blog Author One'
        )
        cls.commenter_user = User.objects.create_user(
            username='blog_commenter1',
            email='blogcommenter1@example.com',
            password='password123',
            full_name='Blog Commenter One'
        )
        cls.admin_user = User.objects.create_superuser(
            username='blog_admin',
            email='blogadmin@example.com',
            password='password123',
            full_name='Blog Admin'
        )

        # Create Blog Categories
        cls.cat_tech = BlogCategory.objects.create(name='Technology', slug='technology')
        cls.cat_tutorials = BlogCategory.objects.create(name='Tutorials', slug='tutorials')

        # Create Blog Post Tags
        cls.tag_python = BlogPostTag.objects.create(name='Python', slug='python')
        cls.tag_django = BlogPostTag.objects.create(name='Django', slug='django')
        cls.tag_webdev = BlogPostTag.objects.create(name='Web Development', slug='web-development')

        # Create Blog Posts
        cls.post_published = BlogPost.objects.create(
            author=cls.author_user,
            category=cls.cat_tech,
            title='Understanding Django Signals',
            slug='understanding-django-signals', # Explicit slug for predictability
            excerpt='A deep dive into how signals work in Django.',
            content_markdown='## Introduction\nSignals are a powerful feature...',
            status='published',
            # published_at will be set by save() method
        )
        cls.post_published.tags.add(cls.tag_django, cls.tag_python)

        cls.post_draft = BlogPost.objects.create(
            author=cls.author_user,
            category=cls.cat_tutorials,
            title='Draft: Python List Comprehensions',
            # Slug will be auto-generated by save()
            excerpt='Quick guide to list comprehensions.',
            content_markdown='List comprehensions offer a concise way to create lists.',
            status='draft'
        )
        cls.post_draft.tags.add(cls.tag_python)

        # Create a Blog Comment
        cls.comment1_on_published = BlogComment.objects.create(
            blog_post=cls.post_published,
            author=cls.commenter_user,
            content='Great article, very informative!'
        )
        # comment_count signal should update post_published

        cls.comment2_reply_to_c1 = BlogComment.objects.create(
            blog_post=cls.post_published,
            author=cls.author_user, # Author replying
            parent_comment=cls.comment1_on_published,
            content='Thanks for the feedback!'
        )

        cls.comment3_unapproved = BlogComment.objects.create(
            blog_post=cls.post_published,
            author=cls.commenter_user,
            content='This comment needs approval.',
            is_approved=False
        )


class BlogCategoryModelTests(BlogModelTestDataMixin, TestCase):
    def test_blog_category_creation(self):
        self.assertEqual(self.cat_tech.name, 'Technology')
        self.assertEqual(self.cat_tech.slug, 'technology')
        self.assertEqual(self.cat_tech.post_count, 0) # Initially 0, updated by BlogPost signal
        self.assertEqual(str(self.cat_tech), 'Technology')

    def test_blog_category_name_uniqueness(self):
        with self.assertRaises(IntegrityError):
            BlogCategory.objects.create(name='Technology', slug='tech-new')

    def test_blog_category_slug_uniqueness(self):
        with self.assertRaises(IntegrityError):
            BlogCategory.objects.create(name='Tech New', slug='technology')


class BlogPostTagModelTests(BlogModelTestDataMixin, TestCase):
    def test_blog_post_tag_creation(self):
        self.assertEqual(self.tag_python.name, 'Python')
        self.assertEqual(self.tag_python.slug, 'python')
        self.assertEqual(str(self.tag_python), 'Python')

    def test_blog_post_tag_name_uniqueness(self):
        with self.assertRaises(IntegrityError):
            BlogPostTag.objects.create(name='Python', slug='python-new-slug')

    def test_blog_post_tag_slug_uniqueness(self):
        with self.assertRaises(IntegrityError):
            BlogPostTag.objects.create(name='Python New Name', slug='python')


class BlogPostModelTests(BlogModelTestDataMixin, TestCase):
    def test_blog_post_creation_published(self):
        self.assertEqual(self.post_published.title, 'Understanding Django Signals')
        self.assertEqual(self.post_published.author, self.author_user)
        self.assertEqual(self.post_published.category, self.cat_tech)
        self.assertEqual(self.post_published.status, 'published')
        self.assertIsNotNone(self.post_published.published_at) # Set by save()
        self.assertEqual(self.post_published.tags.count(), 2)
        self.assertIn(self.tag_django, self.post_published.tags.all())
        self.assertEqual(str(self.post_published), 'Understanding Django Signals')
        self.assertEqual(self.post_published.view_count, 0)
        self.assertEqual(self.post_published.like_count, 0)
        # comment_count is tested via signal below

    def test_blog_post_creation_draft(self):
        self.assertEqual(self.post_draft.status, 'draft')
        self.assertIsNone(self.post_draft.published_at) # Should not be set for drafts
        self.assertEqual(self.post_draft.slug, slugify(self.post_draft.title)) # Auto-generated

    def test_blog_post_slug_uniqueness(self):
        with self.assertRaises(IntegrityError):
            BlogPost.objects.create(
                author=self.author_user, title='Another Signal Post',
                slug='understanding-django-signals', # Duplicate
                content_markdown='Test content'
            )

    def test_blog_post_auto_slug_uniqueness_on_save(self):
        # Create a post that would generate the same initial slug as post_draft
        post_same_title = BlogPost.objects.create(
            author=self.author_user,
            title=self.post_draft.title, # Same title
            content_markdown="Content for slug test"
        )
        # The save() method should append a counter to make it unique
        self.assertNotEqual(post_same_title.slug, self.post_draft.slug)
        self.assertTrue(post_same_title.slug.startswith(self.post_draft.slug + '-'))


    def test_published_at_logic_on_save(self):
        # Test draft to published
        self.post_draft.status = 'published'
        self.post_draft.save()
        self.post_draft.refresh_from_db()
        self.assertIsNotNone(self.post_draft.published_at)
        first_published_time = self.post_draft.published_at

        # Test saving again while published (should not change published_at)
        self.post_draft.title = "Updated Draft Title Now Published"
        self.post_draft.save()
        self.post_draft.refresh_from_db()
        self.assertEqual(self.post_draft.published_at, first_published_time)

        # Test published to draft (published_at behavior based on model logic - currently keeps it)
        self.post_draft.status = 'draft'
        self.post_draft.save()
        self.post_draft.refresh_from_db()
        self.assertEqual(self.post_draft.published_at, first_published_time) # Current logic keeps it

    def test_category_post_count_signal_on_blogpost_save_delete(self):
        self.cat_tech.refresh_from_db()
        # post_published is in cat_tech and published
        self.assertEqual(self.cat_tech.post_count, 1)

        # Add another published post to cat_tech
        post_new_published = BlogPost.objects.create(
            author=self.author_user, category=self.cat_tech, title="New Tech Post",
            content_markdown="...", status='published'
        )
        self.cat_tech.refresh_from_db()
        self.assertEqual(self.cat_tech.post_count, 2)

        # Change status of post_new_published to draft
        post_new_published.status = 'draft'
        post_new_published.save()
        self.cat_tech.refresh_from_db()
        self.assertEqual(self.cat_tech.post_count, 1) # Should decrease

        # Delete post_published
        self.post_published.delete()
        self.cat_tech.refresh_from_db()
        self.assertEqual(self.cat_tech.post_count, 0)


class BlogCommentModelTests(BlogModelTestDataMixin, TestCase):
    def test_blog_comment_creation(self):
        self.assertEqual(self.comment1_on_published.blog_post, self.post_published)
        self.assertEqual(self.comment1_on_published.author, self.commenter_user)
        self.assertIn('Great article', self.comment1_on_published.content)
        self.assertTrue(self.comment1_on_published.is_approved) # Default
        self.assertFalse(self.comment1_on_published.is_hidden_by_user)
        self.assertFalse(self.comment1_on_published.is_hidden_by_moderator)
        self.assertTrue(self.comment1_on_published.is_publicly_visible)
        self.assertEqual(self.comment1_on_published.like_count, 0)
        expected_str = f"Comment by {self.commenter_user.email} on '{self.post_published.title}'"
        self.assertEqual(str(self.comment1_on_published), expected_str)

    def test_threaded_comment_creation(self):
        self.assertEqual(self.comment2_reply_to_c1.parent_comment, self.comment1_on_published)
        self.assertEqual(self.comment1_on_published.replies.count(), 1)
        self.assertIn(self.comment2_reply_to_c1, self.comment1_on_published.replies.all())

    def test_is_publicly_visible_property(self):
        # Approved, not hidden
        self.assertTrue(self.comment1_on_published.is_publicly_visible)

        # Unapproved
        self.comment1_on_published.is_approved = False
        self.comment1_on_published.save()
        self.assertFalse(self.comment1_on_published.is_publicly_visible)
        self.comment1_on_published.is_approved = True; self.comment1_on_published.save() # Reset

        # Hidden by user
        self.comment1_on_published.is_hidden_by_user = True
        self.comment1_on_published.save()
        self.assertFalse(self.comment1_on_published.is_publicly_visible)
        self.comment1_on_published.is_hidden_by_user = False; self.comment1_on_published.save() # Reset

        # Hidden by moderator
        self.comment1_on_published.is_hidden_by_moderator = True
        self.comment1_on_published.save()
        self.assertFalse(self.comment1_on_published.is_publicly_visible)

    def test_blog_post_comment_count_signal_on_comment_save_delete(self):
        self.post_published.refresh_from_db()
        # comment1, comment2_reply, comment3_unapproved (but signal counts only approved/visible)
        # comment1 and comment2 are approved and visible by default
        expected_initial_count = 2
        self.assertEqual(self.post_published.comment_count, expected_initial_count)

        # Add a new approved comment
        comment4_approved = BlogComment.objects.create(
            blog_post=self.post_published, author=self.user1, content="Another approved comment."
        )
        self.post_published.refresh_from_db()
        self.assertEqual(self.post_published.comment_count, expected_initial_count + 1)

        # Unapprove comment4
        comment4_approved.is_approved = False
        comment4_approved.save()
        self.post_published.refresh_from_db()
        self.assertEqual(self.post_published.comment_count, expected_initial_count) # Should decrease

        # Delete comment1 (which was approved)
        self.comment1_on_published.delete()
        self.post_published.refresh_from_db()
        # Now only comment2_reply_to_c1 should be counted from the initial set
        self.assertEqual(self.post_published.comment_count, 1)


# Tests for GenericRelation 'likes' on BlogPost and BlogComment
# These depend on having a Like model (e.g., from apps.community)
# and its signals correctly updating the target object's like_count.
# For now, we'll assume BlogPost and BlogComment have a 'like_count' field
# and the GenericRelation is set up. The actual increment/decrement logic
# would be in the Like model's signal.

# Example (if Like model and its signals are available and configured):
# class BlogPostLikeSignalTests(BlogModelTestDataMixin, TestCase):
#     def setUp(self):
#         super().setUpTestData()
#         # Ensure Like model is imported if used from another app
#         # from apps.community.models import Like
#         self.blog_post_ct = ContentType.objects.get_for_model(BlogPost)

#     def test_like_creation_updates_blog_post_like_count(self):
#         initial_likes = self.post_published.like_count
#         # Simulate creating a Like for self.post_published
#         # This assumes community.Like model exists and has a signal to update target.like_count
#         # Like.objects.create(user=self.commenter_user, content_type=self.blog_post_ct, object_id=self.post_published.id)
#         # self.post_published.refresh_from_db()
#         # self.assertEqual(self.post_published.like_count, initial_likes + 1)
#         pass # Placeholder until Like model and its signals are fully integrated and testable here

# Add more tests for:
# - Slug generation edge cases (e.g., very long titles, titles with special characters).
# - Behavior when author or category is None for BlogPost.
# - Deletion cascades if specific on_delete behaviors need verification beyond Django defaults.
# - Any other custom methods or properties on the models.
