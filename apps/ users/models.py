import uuid
import random
from django.contrib.auth.models import AbstractUser, BaseUserManager
from django.db import models
from django.utils.translation import gettext_lazy as _
from django.utils import timezone
from django.conf import settings # For project-wide choices if any
from django.db.models.signals import post_save
from django.dispatch import receiver

# Assuming BaseModel is in apps.core.models
from apps.core.models import BaseModel # Import your BaseModel

# Choices (keeping them here for now, but could be moved to a choices.py or settings)
INDUSTRY_CHOICES = [
    ('Technology', _('Technology')),
    ('Healthcare', _('Healthcare')),
    ('Finance & Banking', _('Finance & Banking')),
    ('Education', _('Education')),
    ('Manufacturing & Engineering', _('Manufacturing & Engineering')),
    ('Retail & E-commerce', _('Retail & E-commerce')),
    ('Marketing & Advertising', _('Marketing & Advertising')),
    ('Arts & Entertainment', _('Arts & Entertainment')),
    ('Student', _('Student (General)')),
    ('Other', _('Other')),
]

LANGUAGE_CHOICES = [
    ('en', _('English')),
    ('es', _('Spanish')),
    ('fr', _('French')),
]

CURRENCY_CHOICES = settings.CURRENCY_CHOICES # Use from settings directly

# Custom User Manager
class UserManager(BaseUserManager):
    """
    Custom user model manager where email is the unique identifiers
    for authentication instead of usernames.
    """
    def create_user(self, email, password, username=None, **extra_fields):
        """
        Create and save a User with the given email and password.
        """
        if not email:
            raise ValueError(_('The Email must be set'))
        email = self.normalize_email(email)
        if not username: # Auto-generate username if not provided
            username = email.split('@')[0] + "_" + str(random.randint(1000,9999))
            while User.objects.filter(username=username).exists(): # Ensure uniqueness
                 username = email.split('@')[0] + "_" + str(random.randint(1000,9999))
        
        extra_fields.setdefault('username', username) # Set username
        user = self.model(email=email, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, email, password, username=None, **extra_fields):
        """
        Create and save a SuperUser with the given email and password.
        """
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)
        extra_fields.setdefault('is_active', True) # Superusers should be active by default

        if extra_fields.get('is_staff') is not True:
            raise ValueError(_('Superuser must have is_staff=True.'))
        if extra_fields.get('is_superuser') is not True:
            raise ValueError(_('Superuser must have is_superuser=True.'))
        
        # Username is required by AbstractUser, ensure it's handled.
        # If not provided in extra_fields, it will be prompted or auto-generated by create_user.
        return self.create_user(email, password, username=username, **extra_fields)


class User(AbstractUser):
    """
    Custom User model inheriting from AbstractUser.
    Uses email as the primary identifier for authentication.
    """
    # Remove username from AbstractUser if email is truly the only identifier
    # However, Django admin and some third-party packages rely on username.
    # We keep username but make email the USERNAME_FIELD.
    # username field is inherited from AbstractUser. We make it non-unique if email is unique.
    # For this iteration, we keep username unique as per AbstractUser default,
    # but ensure it's populated and can be different from email.
    username = models.CharField(
        _('username'),
        max_length=150,
        unique=True,
        help_text=_('Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.'),
        validators=[AbstractUser.username_validator],
        error_messages={
            'unique': _("A user with that username already exists."),
        },
    )
    email = models.EmailField(_('email address'), unique=True, help_text=_("Required. Will be used for login."))

    # Personal Information
    full_name = models.CharField(_("Full Name"), max_length=255, blank=True)
    # first_name and last_name are already in AbstractUser, full_name can be derived or explicit.
    # If explicit, ensure it's populated correctly.

    organization = models.CharField(_("Organization/College/School"), max_length=255, blank=True, null=True)
    industry = models.CharField(
        _("Primary Industry/Field of Study"),
        max_length=100,
        choices=INDUSTRY_CHOICES,
        blank=True,
        null=True
    )
    other_industry_details = models.CharField(
        _("Other Industry Details"),
        max_length=255,
        blank=True,
        null=True,
        help_text=_("Specify if 'Other' is selected for industry.")
    )
    profession = models.CharField(_("Current or Target Profession"), max_length=255, blank=True, null=True)

    # Contact Information
    whatsapp_number = models.CharField(_("WhatsApp Number (with country code)"), max_length=20, unique=True, blank=True, null=True)
    is_whatsapp_verified = models.BooleanField(_("WhatsApp Verified"), default=False)
    whatsapp_verification_code = models.CharField(_("WhatsApp Verification Code"), max_length=6, blank=True, null=True)
    whatsapp_code_created_at = models.DateTimeField(_("WhatsApp Code Created At"), null=True, blank=True)

    # Preferences
    preferred_language = models.CharField(
        _("Preferred Language"),
        max_length=10,
        choices=LANGUAGE_CHOICES,
        default='en'
    )
    preferred_currency = models.CharField(
        _("Preferred Currency"),
        max_length=3,
        choices=CURRENCY_CHOICES, # Referencing from settings
        default='USD'
    )
    profile_picture_url = models.URLField(_("Profile Picture URL"), max_length=1024, blank=True, null=True)
    # For actual image uploads, consider:
    # profile_picture = models.ImageField(upload_to='profile_pictures/', null=True, blank=True)


    # Platform Specific
    career_interest = models.CharField(
        _("Career Interest"),
        max_length=255,
        blank=True,
        null=True,
    )
    uplas_xp_points = models.PositiveIntegerField(_("Uplas XP Points"), default=0)

    # Subscription Details (denormalized for quick access, canonical source is payments app)
    is_premium_subscriber = models.BooleanField(_("Is Premium Subscriber"), default=False)
    # Consider making these fields read-only in admin if managed by payment app signals
    # subscription_plan_name = models.CharField(_("Current Plan Name (Denormalized)"), max_length=100, blank=True, null=True)
    # subscription_end_date = models.DateField(_("Subscription End Date"), null=True, blank=True)

    # Location
    country = models.CharField(_("Country"), max_length=100, blank=True, null=True)
    city = models.CharField(_("City"), max_length=100, blank=True, null=True)

    # Stripe Customer ID (moved here from UserProfile as per your existing model)
    stripe_customer_id = models.CharField(max_length=255, blank=True, null=True, help_text=_("Stripe Customer ID, managed by the payments system."))

    # Timestamps (AbstractUser already has date_joined, last_login)
    # If you need created_at/updated_at different from date_joined/last_login, add them.
    # Otherwise, UserProfile will have them if it inherits from BaseModel.
    created_at = models.DateTimeField(auto_now_add=True, editable=False, null=True, blank=True) # Adding for consistency
    updated_at = models.DateTimeField(auto_now=True, editable=False, null=True, blank=True)


    USERNAME_FIELD = 'email' # Use email for login
    REQUIRED_FIELDS = ['username'] # username is still required for superuser creation, etc.

    objects = UserManager() # Use the custom manager

    class Meta:
        verbose_name = _('User')
        verbose_name_plural = _('Users')
        ordering = ['-created_at', 'email']


    def save(self, *args, **kwargs):
        # Populate full_name from first_name and last_name if empty
        if not self.full_name and (self.first_name or self.last_name):
            self.full_name = f"{self.first_name or ''} {self.last_name or ''}".strip()
        
        # Ensure username is populated, especially if AbstractUser's default manager isn't used for all creations
        # The custom UserManager handles this for creates through objects.create_user/create_superuser
        if not self.username and self.email:
            base_username = self.email.split('@')[0].replace('.', '_').replace('-', '_')[:130] # Max 150, leave room for counter
            temp_username = base_username
            counter = 1
            while User.objects.filter(username=temp_username).exclude(pk=self.pk).exists():
                temp_username = f"{base_username}_{counter}"
                counter += 1
            self.username = temp_username

        super().save(*args, **kwargs)

    def __str__(self):
        return self.email # Primary identifier display
        
    def generate_whatsapp_code(self):
        """Generates a 6-digit verification code for WhatsApp."""
        self.whatsapp_verification_code = str(random.randint(100000, 999999))
        self.whatsapp_code_created_at = timezone.now()
        # Save only the necessary fields to avoid unintended side effects of full save
        self.save(update_fields=['whatsapp_verification_code', 'whatsapp_code_created_at'])
        return self.whatsapp_verification_code

    # @property
    # def has_active_subscription(self): # This logic better lives in payments app or UserSubscription model
    #     if self.is_premium_subscriber and self.subscription_end_date:
    #         return self.subscription_end_date >= timezone.now().date()
    #     return False


class UserProfile(BaseModel): # Inherits UUID id, created_at, updated_at from BaseModel
    """
    Stores additional profile information related to a User.
    Linked OneToOne with the User model.
    """
    user = models.OneToOneField(
        settings.AUTH_USER_MODEL, # Use settings.AUTH_USER_MODEL for flexibility
        on_delete=models.CASCADE,
        related_name='profile', # Allows user.profile access
        verbose_name=_('User')
    )
    bio = models.TextField(_("Short Bio / Professional Summary"), blank=True, null=True)
    
    # Social & Professional Links
    linkedin_url = models.URLField(_("LinkedIn Profile URL"), blank=True, null=True)
    github_url = models.URLField(_("GitHub Profile URL"), blank=True, null=True)
    website_url = models.URLField(_("Personal Website/Portfolio URL"), blank=True, null=True)

    # AI Personalization Preferences
    preferred_tutor_persona = models.CharField(
        _("Preferred AI Tutor Persona"), max_length=50, blank=True, null=True,
        help_text=_("e.g., Formal, Friendly, Technical, Socratic, Humorous")
    )
    preferred_tts_voice_character = models.CharField(
        _("Preferred TTS Voice Character"), max_length=50, blank=True, null=True,
        help_text=_("e.g., alloy, echo, fable, onyx, nova, shimmer (from OpenAI TTS)")
    )
    preferred_ttv_instructor = models.CharField(
        _("Preferred TTV Instructor"), max_length=20,
        choices=[('uncle_trevor', _('Uncle Trevor')), ('susan', _('Susan'))], # Make choices translatable
        blank=True, null=True
    )
    # More structured learning preferences
    learning_style_preference = models.JSONField(
        _("Learning Style Preferences (e.g., VARK)"), blank=True, null=True, default=dict,
        help_text=_("Example: {'visual': 0.7, 'auditory': 0.5, 'kinesthetic': 0.3, 'reading_writing': 0.6}")
    )
    areas_of_interest = models.JSONField( # Could also be ManyToMany to a Tag model if interests are predefined
        _("Specific Areas of Interest for Learning"), blank=True, null=True, default=list,
        help_text=_("List of topics or fields, e.g., ['NLP', 'Computer Vision', 'Web Security']")
    )
    current_knowledge_level = models.JSONField( # Or link to skills assessment model
        _("Self-Assessed Knowledge Levels per Topic/Skill"), blank=True, null=True, default=dict,
        help_text=_("Example: {'python-basics': 'Advanced', 'ml-intro': 'Beginner', 'api-design': 'Intermediate'}")
    )
    learning_goals = models.TextField(
        _("User's Stated Learning Goals or Objectives"),
        blank=True, null=True,
        help_text=_("What the user wants to achieve on the platform.")
    )

    # Other preferences
    # email_notifications_enabled = models.BooleanField(default=True)
    # marketing_emails_subscribed = models.BooleanField(default=False)

    # Note: stripe_customer_id was moved to the User model directly in your provided file.
    # If it were here:
    # stripe_customer_id = models.CharField(max_length=255, blank=True, null=True, help_text="Stripe Customer ID")


    class Meta:
        verbose_name = _('User Profile')
        verbose_name_plural = _('User Profiles')
        # ordering is inherited from BaseModel ('-created_at')

    def __str__(self):
        return f"{self.user.email}'s Profile"


# Signal to create or update UserProfile when a User instance is saved.
@receiver(post_save, sender=settings.AUTH_USER_MODEL)
def create_or_update_user_profile_receiver(sender, instance, created, **kwargs):
    """
    Ensures a UserProfile exists for every User.
    """
    if created:
        UserProfile.objects.create(user=instance)
    else:
        # Ensure profile exists, especially if it might have been deleted or missed
        # for some reason (though OneToOne with on_delete=CASCADE should handle User deletion).
        # Accessing instance.profile will create it if it does not exist due to the signal,
        # but it's good to be explicit or rely on the related_name behavior.
        try:
            instance.profile.save() # Save profile if user is updated (e.g., if profile fields depend on user fields)
        except UserProfile.DoesNotExist:
            UserProfile.objects.create(user=instance) # Safeguard for existing users without a profile
